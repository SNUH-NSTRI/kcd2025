# Offline Vocabulary Setup for Trialist Agent

## üéØ ÎÇ¥Î∂ÄÎßù ÌôòÍ≤ΩÏùÑ ÏúÑÌïú Ïò§ÌîÑÎùºÏù∏ Ïñ¥Ìúò Íµ¨Ï∂ï Î∞©Ïïà

ÎÇ¥Î∂ÄÎßù ÌôòÍ≤ΩÏóêÏÑú Trialist AgentÏùò Stage 2 (Standardization) Î∞è Stage 3 (CDM Mapping)ÏùÑ Íµ¨ÌòÑÌïòÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú Ïñ¥Ìúò Îç∞Ïù¥ÌÑ∞Î•º Î°úÏª¨Î°ú Íµ¨Ï∂ïÌïòÎäî Î∞©Î≤ïÏùÑ Ï†úÏãúÌï©ÎãàÎã§.

## üìã ÌïÑÏöî Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§

### 1. UMLS (Unified Medical Language System)
**Îã§Ïö¥Î°úÎìú Î∞©Î≤ï:**
- **Í≥µÏãù ÏÇ¨Ïù¥Ìä∏**: https://www.nlm.nih.gov/research/umls/
- **ÎùºÏù¥ÏÑ†Ïä§**: Î¨¥Î£å (UMLS Metathesaurus License Agreement ÌïÑÏöî)
- **ÌååÏùº ÌÅ¨Í∏∞**: ~15GB (ÏïïÏ∂ï), ~50GB (ÏïïÏ∂ï Ìï¥Ï†ú)
- **ÌååÏùº ÌòïÌÉú**: MySQL dump, RRF files

**Ï£ºÏöî ÌÖåÏù¥Î∏î:**
```
MRCONSO.RRF  - Concept names and sources (ÌïµÏã¨)
MRSTY.RRF    - Semantic types
MRREL.RRF    - Related concepts
MRRANK.RRF   - Source ranking
MRSAT.RRF    - Simple attributes
```

### 2. OHDSI Athena Vocabularies
**Îã§Ïö¥Î°úÎìú Î∞©Î≤ï:**
- **ÏÇ¨Ïù¥Ìä∏**: https://athena.ohdsi.org/
- **Í≥ÑÏ†ï**: Î¨¥Î£å Îì±Î°ù ÌõÑ Îã§Ïö¥Î°úÎìú
- **ÌååÏùº ÌÅ¨Í∏∞**: ~5GB (ÏïïÏ∂ï)
- **ÏóÖÎç∞Ïù¥Ìä∏**: ÏõîÎ≥Ñ

**Ï£ºÏöî ÌååÏùº:**
```
CONCEPT.csv           - All concepts
CONCEPT_RELATIONSHIP.csv - Relationships between concepts
CONCEPT_SYNONYM.csv   - Alternative names
VOCABULARY.csv        - Vocabulary metadata
DOMAIN.csv           - Domain classifications
```

### 3. Í∞úÎ≥Ñ ÌëúÏ§Ä Ïñ¥Ìúò
- **ICD-10-CM**: CDCÏóêÏÑú Î¨¥Î£å Ï†úÍ≥µ
- **RxNorm**: NLMÏóêÏÑú Î¨¥Î£å Ï†úÍ≥µ
- **LOINC**: Regenstrief Institute (Î¨¥Î£å Îì±Î°ù)
- **SNOMED CT**: Íµ≠Í∞ÄÎ≥Ñ ÎùºÏù¥ÏÑ†Ïä§ (ÌïúÍµ≠: Í±¥Í∞ïÎ≥¥ÌóòÏã¨ÏÇ¨ÌèâÍ∞ÄÏõê)

## üóÑÔ∏è Î°úÏª¨ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Í≥Ñ

### SQLite Í∏∞Î∞ò Í≤ΩÎüâ Íµ¨Ï°∞
```sql
-- concepts ÌÖåÏù¥Î∏î: Î™®Îì† Í∞úÎÖê Ï†ïÎ≥¥
CREATE TABLE concepts (
    concept_id INTEGER PRIMARY KEY,
    concept_name TEXT NOT NULL,
    domain_id TEXT,
    vocabulary_id TEXT,
    concept_class_id TEXT,
    concept_code TEXT,
    valid_start_date DATE,
    valid_end_date DATE,
    invalid_reason TEXT
);

-- concept_synonyms ÌÖåÏù¥Î∏î: ÎèôÏùòÏñ¥ Îß§Ìïë
CREATE TABLE concept_synonyms (
    synonym_id INTEGER PRIMARY KEY,
    concept_id INTEGER,
    synonym_name TEXT,
    language_concept_id INTEGER,
    FOREIGN KEY (concept_id) REFERENCES concepts (concept_id)
);

-- concept_relationships ÌÖåÏù¥Î∏î: Í∞úÎÖê Í∞Ñ Í¥ÄÍ≥Ñ
CREATE TABLE concept_relationships (
    relationship_id INTEGER PRIMARY KEY,
    concept_id_1 INTEGER,
    concept_id_2 INTEGER,
    relationship_id_code TEXT,
    valid_start_date DATE,
    valid_end_date DATE,
    FOREIGN KEY (concept_id_1) REFERENCES concepts (concept_id),
    FOREIGN KEY (concept_id_2) REFERENCES concepts (concept_id)
);

-- domain_mapping ÌÖåÏù¥Î∏î: Trialist domain Îß§Ìïë
CREATE TABLE domain_mapping (
    mapping_id INTEGER PRIMARY KEY,
    trialist_domain TEXT,  -- "Condition", "Drug", etc.
    omop_domain_id TEXT,   -- "Condition", "Drug", etc.
    vocabulary_preference INTEGER  -- 1=primary, 2=secondary
);
```

### Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî
```sql
CREATE INDEX idx_concepts_name ON concepts(concept_name);
CREATE INDEX idx_concepts_code ON concepts(concept_code);
CREATE INDEX idx_synonyms_name ON concept_synonyms(synonym_name);
CREATE INDEX idx_synonyms_concept ON concept_synonyms(concept_id);
```

## üõ†Ô∏è Íµ¨ÌòÑ Í≥ÑÌöç

### Phase 1: Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Î∞è Ï†ÑÏ≤òÎ¶¨
```python
# vocabulary_builder.py
class VocabularyBuilder:
    def __init__(self, data_dir: Path, db_path: Path):
        self.data_dir = data_dir
        self.db_path = db_path
    
    def download_umls(self):
        """UMLS Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú (ÏàòÎèô Îã§Ïö¥Î°úÎìú ÌõÑ Ï≤òÎ¶¨)"""
        
    def download_athena(self):
        """Athena Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú"""
        
    def process_umls_files(self):
        """UMLS RRF ÌååÏùºÎì§ÏùÑ SQLiteÎ°ú Î≥ÄÌôò"""
        
    def process_athena_files(self):
        """Athena CSV ÌååÏùºÎì§ÏùÑ SQLiteÎ°ú Î≥ÄÌôò"""
        
    def build_unified_database(self):
        """ÌÜµÌï© Ïñ¥Ìúò DB Íµ¨Ï∂ï"""
```

### Phase 2: Ïò§ÌîÑÎùºÏù∏ ÌëúÏ§ÄÌôî Î™®Îìà
```python
# offline_standardizer.py  
class OfflineStandardizer:
    def __init__(self, db_path: Path):
        self.db = sqlite3.connect(db_path)
        self._setup_fuzzy_matching()
    
    def standardize_concept(self, text: str, domain: str) -> StandardizedConcept:
        """ÌÖçÏä§Ìä∏Î•º ÌëúÏ§Ä Í∞úÎÖêÏúºÎ°ú Îß§Ìïë"""
        
    def find_best_matches(self, text: str, limit: int = 5):
        """Ïú†ÏÇ¨ÎèÑ Í∏∞Î∞ò Îß§Ïπ≠"""
        
    def get_domain_vocabularies(self, trialist_domain: str) -> List[str]:
        """ÎèÑÎ©îÏù∏Î≥Ñ Ïö∞ÏÑ† Ïñ¥Ìúò Î∞òÌôò"""
```

### Phase 3: Í≥†Í∏â Îß§Ïπ≠ ÏïåÍ≥†Î¶¨Ï¶ò
```python
from difflib import SequenceMatcher
from fuzzywuzzy import fuzz
import re

class ConceptMatcher:
    def __init__(self, db_connection):
        self.db = db_connection
        self.abbreviation_map = self._load_abbreviations()
    
    def fuzzy_match(self, query: str, threshold: float = 0.8):
        """ÌçºÏßÄ Îß§Ïπ≠ÏùÑ ÌÜµÌïú Í∞úÎÖê Í≤ÄÏÉâ"""
        
    def exact_match(self, query: str):
        """Ï†ïÌôïÌïú Îß§Ïπ≠"""
        
    def abbreviation_expand(self, text: str):
        """ÏïΩÏñ¥ ÌôïÏû• (MI -> Myocardial Infarction)"""
        
    def semantic_match(self, query: str, domain: str):
        """ÎèÑÎ©îÏù∏Î≥Ñ ÏùòÎØ∏Î°†Ï†Å Îß§Ïπ≠"""
```

## üì¶ Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ Ïä§ÌÅ¨Î¶ΩÌä∏

### 1. UMLS Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
```python
# scripts/build_umls_db.py
import pandas as pd
import sqlite3
from pathlib import Path

def process_mrconso_file(rrf_path: Path, db_path: Path):
    """MRCONSO.RRF ÌååÏùºÏùÑ SQLiteÎ°ú Î≥ÄÌôò"""
    
    # RRF ÌååÏùº Ïª¨Îüº Ï†ïÏùò
    columns = [
        'CUI', 'LAT', 'TS', 'LUI', 'STT', 'SUI', 'ISPREF', 'AUI',
        'SAUI', 'SCUI', 'SDUI', 'SAB', 'TTY', 'CODE', 'STR', 'SRL', 'SUPPRESS', 'CVF'
    ]
    
    # Ï≤≠ÌÅ¨Î≥ÑÎ°ú Ï≤òÎ¶¨ (Î©îÎ™®Î¶¨ Ìö®Ïú®ÏÑ±)
    chunk_size = 10000
    
    with sqlite3.connect(db_path) as conn:
        for chunk in pd.read_csv(rrf_path, sep='|', names=columns, 
                                 chunksize=chunk_size, dtype=str):
            # ÏòÅÏñ¥Îßå ÌïÑÌÑ∞ÎßÅ
            chunk = chunk[chunk['LAT'] == 'ENG']
            
            # ÌïÑÏöîÌïú Ïª¨ÎüºÎßå ÏÑ†ÌÉù
            processed = chunk[['CUI', 'STR', 'SAB', 'CODE']].copy()
            processed.columns = ['umls_cui', 'concept_name', 'source', 'source_code']
            
            # SQLiteÏóê ÏÇΩÏûÖ
            processed.to_sql('umls_concepts', conn, if_exists='append', index=False)

if __name__ == "__main__":
    # ÏÇ¨Ïö© ÏòàÏãú
    umls_dir = Path("data/umls/2024AA/META")
    db_path = Path("vocabularies/umls.db")
    
    process_mrconso_file(umls_dir / "MRCONSO.RRF", db_path)
```

### 2. Athena Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
```python
# scripts/build_athena_db.py
def process_athena_concepts(csv_dir: Path, db_path: Path):
    """Athena CONCEPT.csvÎ•º SQLiteÎ°ú Î≥ÄÌôò"""
    
    concept_df = pd.read_csv(csv_dir / "CONCEPT.csv", sep='\t')
    
    # Trialist domain Îß§Ìïë Ï∂îÍ∞Ä
    domain_mapping = {
        'Condition': ['Condition'],
        'Drug': ['Drug'], 
        'Measurement': ['Measurement'],
        'Procedure': ['Procedure'],
        'Device': ['Device'],
        'Observation': ['Observation'],
        'Visit': ['Visit']
    }
    
    with sqlite3.connect(db_path) as conn:
        concept_df.to_sql('athena_concepts', conn, if_exists='replace', index=False)
        
        # ÎèÑÎ©îÏù∏ Îß§Ìïë ÌÖåÏù¥Î∏î ÏÉùÏÑ±
        mapping_rows = []
        for trialist_domain, omop_domains in domain_mapping.items():
            for i, omop_domain in enumerate(omop_domains, 1):
                mapping_rows.append({
                    'trialist_domain': trialist_domain,
                    'omop_domain_id': omop_domain,
                    'vocabulary_preference': i
                })
        
        mapping_df = pd.DataFrame(mapping_rows)
        mapping_df.to_sql('domain_mapping', conn, if_exists='replace', index=False)
```

## üîß Trialist Parser Ïò§ÌîÑÎùºÏù∏ Î™®Îìú Íµ¨ÌòÑ

```python
# trialist_offline_stages.py
from pathlib import Path
import sqlite3
from typing import List, Optional, Tuple

class OfflineStandardizationStage:
    def __init__(self, vocab_db_path: Path):
        self.db_path = vocab_db_path
        self.db = None
    
    def __enter__(self):
        self.db = sqlite3.connect(self.db_path)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.db:
            self.db.close()
    
    def standardize_entity(self, entity: EnhancedNamedEntity) -> EnhancedNamedEntity:
        """EntityÎ•º ÌëúÏ§ÄÌôî"""
        
        # 1. Ï†ïÌôïÌïú Îß§Ïπ≠ ÏãúÎèÑ
        exact_match = self._exact_match(entity.text, entity.domain)
        if exact_match:
            return self._create_standardized_entity(entity, exact_match)
        
        # 2. ÌçºÏßÄ Îß§Ïπ≠ ÏãúÎèÑ  
        fuzzy_matches = self._fuzzy_match(entity.text, entity.domain)
        if fuzzy_matches:
            best_match = fuzzy_matches[0]  # ÏµúÍ≥† Ï†êÏàò
            if best_match['similarity'] > 0.8:
                return self._create_standardized_entity(entity, best_match)
        
        # 3. ÌëúÏ§ÄÌôî Ïã§Ìå®Ïãú ÏõêÎ≥∏ Î∞òÌôò
        return entity
    
    def _exact_match(self, text: str, domain: str) -> Optional[dict]:
        """Ï†ïÌôïÌïú ÌÖçÏä§Ìä∏ Îß§Ïπ≠"""
        query = """
        SELECT ac.concept_id, ac.concept_name, ac.vocabulary_id, ac.concept_code,
               uc.umls_cui
        FROM athena_concepts ac
        LEFT JOIN umls_concepts uc ON LOWER(ac.concept_name) = LOWER(uc.concept_name)
        JOIN domain_mapping dm ON ac.domain_id = dm.omop_domain_id
        WHERE LOWER(ac.concept_name) = LOWER(?)
          AND dm.trialist_domain = ?
          AND ac.invalid_reason IS NULL
        ORDER BY dm.vocabulary_preference
        LIMIT 1
        """
        
        cursor = self.db.execute(query, (text.lower(), domain))
        row = cursor.fetchone()
        
        if row:
            return {
                'concept_id': row[0],
                'concept_name': row[1], 
                'vocabulary_id': row[2],
                'concept_code': row[3],
                'umls_cui': row[4],
                'similarity': 1.0
            }
        return None
    
    def _fuzzy_match(self, text: str, domain: str, limit: int = 5) -> List[dict]:
        """Ïú†ÏÇ¨ÎèÑ Í∏∞Î∞ò Îß§Ïπ≠"""
        # SQLite LIKE Í≤ÄÏÉâÏúºÎ°ú ÌõÑÎ≥¥ Ï∂ïÏÜå
        query = """
        SELECT ac.concept_id, ac.concept_name, ac.vocabulary_id, ac.concept_code,
               uc.umls_cui
        FROM athena_concepts ac
        LEFT JOIN umls_concepts uc ON LOWER(ac.concept_name) = LOWER(uc.concept_name)
        JOIN domain_mapping dm ON ac.domain_id = dm.omop_domain_id
        WHERE ac.concept_name LIKE ?
          AND dm.trialist_domain = ?
          AND ac.invalid_reason IS NULL
        ORDER BY dm.vocabulary_preference
        LIMIT 50
        """
        
        cursor = self.db.execute(query, (f"%{text[:3]}%", domain))
        candidates = cursor.fetchall()
        
        # PythonÏóêÏÑú Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
        matches = []
        for candidate in candidates:
            similarity = self._calculate_similarity(text, candidate[1])
            if similarity > 0.6:  # ÏûÑÍ≥ÑÍ∞í
                matches.append({
                    'concept_id': candidate[0],
                    'concept_name': candidate[1],
                    'vocabulary_id': candidate[2], 
                    'concept_code': candidate[3],
                    'umls_cui': candidate[4],
                    'similarity': similarity
                })
        
        return sorted(matches, key=lambda x: x['similarity'], reverse=True)[:limit]
    
    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """ÌÖçÏä§Ìä∏ Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞"""
        from difflib import SequenceMatcher
        
        # Ï†ÑÏ≤òÎ¶¨
        text1 = text1.lower().strip()
        text2 = text2.lower().strip()
        
        # Ï†ïÌôïÌïú Îß§Ïπ≠
        if text1 == text2:
            return 1.0
        
        # ÏàúÏ∞® Ïú†ÏÇ¨ÎèÑ
        seq_sim = SequenceMatcher(None, text1, text2).ratio()
        
        # Îã®Ïñ¥ Í∏∞Î∞ò Ïú†ÏÇ¨ÎèÑ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
        words1 = set(text1.split())
        words2 = set(text2.split())
        
        if words1 and words2:
            word_sim = len(words1.intersection(words2)) / len(words1.union(words2))
            return max(seq_sim, word_sim)
        
        return seq_sim
    
    def _create_standardized_entity(self, original: EnhancedNamedEntity, match: dict) -> EnhancedNamedEntity:
        """ÌëúÏ§ÄÌôîÎêú entity ÏÉùÏÑ±"""
        return EnhancedNamedEntity(
            text=original.text,
            type=original.type,
            domain=original.domain,
            start=original.start,
            end=original.end,
            confidence=original.confidence,
            # ÌëúÏ§ÄÌôî Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            standard_name=match['concept_name'],
            umls_cui=match['umls_cui'],
            code_system=match['vocabulary_id'],
            code_set=[match['concept_code']] if match['concept_code'] else None,
            primary_code=match['concept_code'],
            metadata={
                **(original.metadata or {}),
                'standardization': {
                    'method': 'offline_exact' if match['similarity'] == 1.0 else 'offline_fuzzy',
                    'similarity_score': match['similarity'],
                    'concept_id': match['concept_id']
                }
            }
        )
```

## üìã ÏÑ§Ïπò Î∞è ÏÑ§Ï†ï Í∞ÄÏù¥Îìú

### 1. Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú Ïä§ÌÅ¨Î¶ΩÌä∏
```bash
#!/bin/bash
# setup_offline_vocab.sh

echo "Setting up offline vocabularies for Trialist Agent..."

# ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
mkdir -p data/vocabularies
mkdir -p data/raw/umls
mkdir -p data/raw/athena

# UMLS Îã§Ïö¥Î°úÎìú ÏïàÎÇ¥ (ÏàòÎèô)
echo "1. UMLS Îã§Ïö¥Î°úÎìú:"
echo "   - https://uts.nlm.nih.gov/uts/ ÏóêÏÑú Í≥ÑÏ†ï ÏÉùÏÑ±"
echo "   - UMLS Metathesaurus Îã§Ïö¥Î°úÎìú"
echo "   - data/raw/umls/ Ïóê ÏïïÏ∂ï Ìï¥Ï†ú"
echo ""

# Athena Îã§Ïö¥Î°úÎìú ÏïàÎÇ¥ (ÏàòÎèô)
echo "2. Athena Îã§Ïö¥Î°úÎìú:"
echo "   - https://athena.ohdsi.org/ ÏóêÏÑú Í≥ÑÏ†ï ÏÉùÏÑ±"
echo "   - ÌïÑÏöîÌïú vocabulary ÏÑ†ÌÉù ÌõÑ Îã§Ïö¥Î°úÎìú"
echo "   - data/raw/athena/ Ïóê ÏïïÏ∂ï Ìï¥Ï†ú"
echo ""

# Ï≤òÎ¶¨ Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
echo "3. Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë..."
python scripts/build_vocabulary_db.py

echo "Ïò§ÌîÑÎùºÏù∏ Ïñ¥Ìúò ÏÑ§Ï†ï ÏôÑÎ£å!"
```

### 2. ÌÜµÌï© ÎπåÎìú Ïä§ÌÅ¨Î¶ΩÌä∏
```python
# scripts/build_vocabulary_db.py
def main():
    """Ïò§ÌîÑÎùºÏù∏ Ïñ¥Ìúò DB ÌÜµÌï© ÎπåÎìú"""
    
    raw_data_dir = Path("data/raw")
    vocab_db_path = Path("data/vocabularies/trialist_vocab.db")
    
    print("Building offline vocabulary database...")
    
    # 1. UMLS Ï≤òÎ¶¨
    if (raw_data_dir / "umls/META").exists():
        print("Processing UMLS data...")
        process_umls_data(raw_data_dir / "umls/META", vocab_db_path)
    
    # 2. Athena Ï≤òÎ¶¨  
    if (raw_data_dir / "athena").exists():
        print("Processing Athena data...")
        process_athena_data(raw_data_dir / "athena", vocab_db_path)
    
    # 3. Ïù∏Îç±Ïä§ ÏÉùÏÑ±
    print("Creating database indexes...")
    create_indexes(vocab_db_path)
    
    print(f"Vocabulary database created: {vocab_db_path}")
    print(f"Database size: {vocab_db_path.stat().st_size / 1024 / 1024:.1f} MB")

if __name__ == "__main__":
    main()
```

Ïù¥ Î∞©Î≤ïÏúºÎ°ú ÏôÑÏ†ÑÌûà Ïò§ÌîÑÎùºÏù∏ ÌôòÍ≤ΩÏóêÏÑúÎèÑ Trialist AgentÏùò ÌëúÏ§ÄÌôî Î∞è CDM Îß§Ìïë Í∏∞Îä•ÏùÑ Íµ¨ÌòÑÌï† Ïàò ÏûàÏäµÎãàÎã§. Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìúÎßå Ïù∏ÌÑ∞ÎÑ∑Ïù¥ ÌïÑÏöîÌïòÍ≥†, Ïù¥ÌõÑÏóêÎäî Î™®Îì† Ï≤òÎ¶¨Í∞Ä Î°úÏª¨ÏóêÏÑú ÏßÑÌñâÎê©ÎãàÎã§.